---
title: æ–œç‡ä¼˜åŒ–dpå…¥é—¨
tags:
  - ç®—æ³•
createTime: 2021/06/25 21:53:49
permalink: /blog/0citx3x6/
---

# æ–œç‡ä¼˜åŒ– dp

## å‰ç½®çŸ¥è¯†

| åç§°     | å®šä¹‰                                             |
| -------- | ------------------------------------------------ |
| å‡¸å¤šè¾¹å½¢ | æ‰€æœ‰å†…è§’éƒ½åœ¨$(0Â°,180Â°)$çš„ç®€å•å¤šè¾¹å½¢              |
| å‡¸åŒ…     | åœ¨å¹³é¢ä¸Šèƒ½åŒ…å«æ‰€æœ‰ç»™å®šç‚¹çš„æœ€å°å‡¸å¤šè¾¹å½¢å«åšå‡¸åŒ…ã€‚ |
| ä¸Šå‡¸åŒ…   | å‡¸åŒ…ä¸­æ¨ªåæ ‡æœ€å°çš„ç‚¹åˆ°æ¨ªåæ ‡æœ€å¤§çš„ç‚¹çš„ä¸ŠåŠéƒ¨åˆ†   |
| ä¸‹å‡¸åŒ…   | å‡¸åŒ…ä¸­æ¨ªåæ ‡æœ€å°çš„ç‚¹åˆ°æ¨ªåæ ‡æœ€å¤§çš„ç‚¹çš„ä¸‹åŠéƒ¨åˆ†   |

å¦‚å³å›¾ï¼Œè“è‰²éƒ¨åˆ†æ˜¯ä¸Šå‡¸åŒ…ï¼Œæ©™è‰²éƒ¨åˆ†æ˜¯ä¸‹å‡¸åŒ…

<img src="https://image.honahec.cc/dp21001-001.png" style="zoom:25%;" />

> è®©æˆ‘ä»¬é€šè¿‡ä¾‹é¢˜æ¥å­¦ä¹ æ–œç‡ä¼˜åŒ–$dp$

## ä¾‹é¢˜

### [[HNOI2008] ç©å…·è£…ç®±](https://www.luogu.com.cn/problem/P3195)

#### é¢˜ç›®æè¿°

P æ•™æˆè¦å»çœ‹å¥¥è¿ï¼Œä½†æ˜¯ä»–èˆä¸ä¸‹ä»–çš„ç©å…·ï¼Œäºæ˜¯ä»–å†³å®šæŠŠæ‰€æœ‰çš„ç©å…·è¿åˆ°åŒ—äº¬ã€‚ä»–ä½¿ç”¨è‡ªå·±çš„å‹ç¼©å™¨è¿›è¡Œå‹ç¼©ï¼Œå…¶å¯ä»¥å°†ä»»æ„ç‰©å“å˜æˆä¸€å †ï¼Œå†æ”¾åˆ°ä¸€ç§ç‰¹æ®Šçš„ä¸€ç»´å®¹å™¨ä¸­ã€‚

P æ•™æˆæœ‰ç¼–å·ä¸º $1 \cdots n$ çš„ $n$ ä»¶ç©å…·ï¼Œç¬¬ä»¶ç©å…·ç»è¿‡å‹ç¼©åçš„ä¸€ç»´é•¿åº¦ä¸º $C_i$ã€‚

ä¸ºäº†æ–¹ä¾¿æ•´ç†ï¼ŒP æ•™æˆè¦æ±‚ï¼š

- åœ¨ä¸€ä¸ªä¸€ç»´å®¹å™¨ä¸­çš„ç©å…·ç¼–å·æ˜¯è¿ç»­çš„ã€‚
- åŒæ—¶å¦‚æœä¸€ä¸ªä¸€ç»´å®¹å™¨ä¸­æœ‰å¤šä¸ªç©å…·ï¼Œé‚£ä¹ˆä¸¤ä»¶ç©å…·ä¹‹é—´è¦åŠ å…¥ä¸€ä¸ªå•ä½é•¿åº¦çš„å¡«å……ç‰©ã€‚å½¢å¼åœ°è¯´ï¼Œå¦‚æœå°†ç¬¬ $i$ ä»¶ç©å…·åˆ°ç¬¬ $j$ ä¸ªç©å…·æ”¾åˆ°ä¸€ä¸ªå®¹å™¨ä¸­ï¼Œé‚£ä¹ˆå®¹å™¨çš„é•¿åº¦å°†ä¸º $x=j-i+\sum_{k=i}^{j}C_k$ã€‚

åˆ¶ä½œå®¹å™¨çš„è´¹ç”¨ä¸å®¹å™¨çš„é•¿åº¦æœ‰å…³ï¼Œæ ¹æ®æ•™æˆç ”ç©¶ï¼Œå¦‚æœå®¹å™¨é•¿åº¦ä¸º $x$ï¼Œå…¶åˆ¶ä½œè´¹ç”¨ä¸º $(x-L)^2$ã€‚å…¶ä¸­ $L$ æ˜¯ä¸€ä¸ªå¸¸é‡ã€‚P æ•™æˆä¸å…³å¿ƒå®¹å™¨çš„æ•°ç›®ï¼Œä»–å¯ä»¥åˆ¶ä½œå‡ºä»»æ„é•¿åº¦çš„å®¹å™¨ï¼Œç”šè‡³è¶…è¿‡ $L$ã€‚ä½†ä»–å¸Œæœ›æ‰€æœ‰å®¹å™¨çš„æ€»è´¹ç”¨æœ€å°ã€‚

#### è¾“å…¥æ ¼å¼

ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°ï¼Œç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œåˆ†åˆ«ä»£è¡¨ $n$ å’Œ $L$ã€‚

ç¬¬ $2$ åˆ° ç¬¬ $(n+1)$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œç¬¬ $(i+1)$ è¡Œçš„æ•´æ•°ä»£è¡¨ç¬¬ $i$ ä»¶ç©å…·çš„é•¿åº¦ $C_i$ã€‚

#### è¾“å‡ºæ ¼å¼

è¾“å‡ºä¸€è¡Œä¸€ä¸ªæ•´æ•°ï¼Œä»£è¡¨æ‰€æœ‰å®¹å™¨çš„æ€»è´¹ç”¨æœ€å°æ˜¯å¤šå°‘ã€‚

#### æ•°æ®èŒƒå›´

å¯¹äºå…¨éƒ¨çš„æµ‹è¯•ç‚¹ï¼Œ$1 \leq n \leq 5 \times 10^4,1 \leq L \leq 10^7,1 \leq C_i \leq 10^7$

### åŸºæœ¬$dp$æ€è·¯

è®¾$F_i$ä¸ºè£…å‰$i$ä¸ªç©å…·çš„æœ€å°è´¹ç”¨ï¼Œåˆ™$F_i=min_{0\leq j<i}(F_j+(i-j-1-L+\sum^{i}_{k=j+1}C_k)^2)$

å…¶ä¸­$\sum^{i}_{k=j+1}C_k$å¯ä»¥ç”¨å‰ç¼€å’Œä¼˜åŒ–æ‰ï¼Œå˜æˆ$F_i=min_{0\leq j<i}(F_j+(i-j-1-L+sum_i-sum_j)^2)$

éå¸¸å¥½å•Šï¼Œ$O(n^2)$ï¼Œ0 åˆ†åˆ°æ‰‹

æ€ä¹ˆåŠå‘¢ï¼Ÿ

### å¤„ç†ä¸€ä¸‹

è¿™ä¸ª$dp$æ–¹ç¨‹å¥½åƒä¸å¤ªå¥½å¤„ç†

é¦–å…ˆæˆ‘ä»¬ä¸çœ‹è¿™ä¸ª$min$ï¼Œåªçœ‹$F_i=F_j+(i-j-1-L+sum_i-sum_j )^2$

$$
\begin{align}
\text{ä»¤}A=i+sum_i,B&=j+sum_j,C=L+1\\
F_j+(A-B-C)^2&=F_j+A^2+(B+C)^2-2A(B+C)\\
F_i+2A(B+C)&=F_j+A^2+(B+C)^2\\
\text{ä»¤}x=B+C,y=F_j&+(B+C)^2,k=2A,b=F_i-A^2\\
y&=kx+b
\end{align}
$$

æƒ³åˆ°äº†ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬è¦æœ€å°åŒ–$F_i$ï¼Œé‚£ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è¦æœ€å°åŒ–$b$

å¯¹äºæ¯ä¸€ä¸ªç¡®å®šçš„$i$ï¼Œ$k$éƒ½æ˜¯ç¡®å®šçš„

é—®é¢˜è½¬åŒ–æˆäº†æ±‚è¿‡$(B+C, F_j+(B+C)^2)$ä¸­ä»»æ„ä¸€ç‚¹ä¸”æ–œç‡ä¸º k çš„ç›´çº¿æˆªè·çš„æœ€å°å€¼ã€‚

#### è¡¥å……çŸ¥è¯†

**å¦‚æœä½ åªæƒ³çŸ¥é“æ–œç‡ä¼˜åŒ–æ€ä¹ˆç”¨ï¼Œé‚£ä¹ˆä½ å¯ä»¥[ç‚¹æ­¤](#å›å½’æ­£é¢˜)è·³è¿‡è¿™éƒ¨åˆ†ã€‚**

æˆ‘ä»¬æ˜“å¯è¯æˆªè·çš„æœ€å°å€¼ä¸€å®šå–åœ¨ä¸‹å‡¸åŒ…ä¸Š

è¯æ˜ï¼šå‡å¦‚æˆªè·çš„æœ€å°å€¼å–åœ¨éä¸‹å‡¸åŒ…ä¸Šçš„ä¸€ä¸ªç‚¹$(x_0,y_0 )$ï¼Œåˆ™æœ‰ä¸¤ç§æƒ…å†µï¼š

ï¼ˆä¸€ï¼‰ ä¸‹å‡¸åŒ…ä¸Šæœ‰ä¸€ä¸ªç‚¹$(x_0,y_1)$

æ‰€ä»¥è¿‡$(x_0,y_0)$çš„ç›´çº¿çš„è§£æå¼ä¸º$y=kx+y_0-kx_0$ï¼Œè¿‡$(x_0,y_1)$çš„ç›´çº¿çš„è§£æå¼ä¸º$y=kx+y_1-kx_0$

æ ¹æ®ä¸‹å‡¸åŒ…çš„å®šä¹‰å¯å¾—$y_0>y_1$ï¼Œæ•…$y_0-kx_0>y_1-kx_1$ï¼ŒçŸ›ç›¾

ï¼ˆäºŒï¼‰ ä¸‹å‡¸åŒ…ä¸Šæ²¡æœ‰å’Œå…¶æ¨ªåæ ‡ç›¸åŒçš„ç‚¹

æ ¹æ®ä¸‹å‡¸åŒ…çš„å®šä¹‰ï¼Œå¯å¾—ä¸‹å‡¸åŒ…ä¸Šä¸€å®šå­˜åœ¨ä¸¤ä¸ªç‚¹$(x_1,y_1)$,$(x_2,y_2)$ä½¿å¾—$x_1<x_0<x_2$ä¸”$x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}<y_0$

æˆ‘ä»¬åœ¨ç»è¿‡$(x_1,y_1)$, $(x_2,y_2)$çš„ç›´çº¿ä¸Šå–ä¸€ç‚¹$(x_0,x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-xx_2})$

- è¿‡$(x_0,y_0)$çš„ç›´çº¿è§£æå¼ä¸º$y=kx+y_0-kx_0$
- è¿‡$(x_0,x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2})$çš„ä¸º$y=kx+x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0$
- è¿‡$(x_1,y_1)$çš„ä¸º$y=kx+y_1-kx_1$
- è¿‡$(x_2,y_2)$çš„ä¸º$y=kx+y_2-kx_2$

ç”±ï¼ˆä¸€ï¼‰å¯å¾—$y_0-kx_0>x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0$

$$
\begin{align}
&k>\frac{y_1-y_2}{x_1-x_2}\\
&(x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2 }-kx_0)-(y_1-kx_1 )\\
&=\frac{x_0 y_1-x_0 y_2+x_1 y_2-x_1 y_1}{x_1-x_2}-k(x_1-x_0)\\
&=\frac{(x_0-x_1)(y_1-y_2)}{x_1-x_2}-k(x_0-x_1)\\
&>\frac{(x_0-x_1 )(y_1-y_2)}{x_1-x_2}-\frac{(x_0-x_1)(y_1-y_2 )}{x_1-x_2}\\
&=0
\end{align}
$$

$$
\begin{align}
&k\leq\frac{y_1-y_2}{x_1-x_2}\\
&(ğ‘¥_0\frac{ğ‘¦_1âˆ’ğ‘¦_2}{ğ‘¥_1âˆ’ğ‘¥_2}+\frac{ğ‘¥_1 ğ‘¦_2âˆ’ğ‘¥_2 ğ‘¦_1}{ğ‘¥_1âˆ’ğ‘¥_2}âˆ’ğ‘˜ğ‘¥_0 )âˆ’(ğ‘¦_2âˆ’ğ‘˜ğ‘¥_2 )\\
&=\frac{ğ‘¥_0 ğ‘¦_1âˆ’ğ‘¥_0 ğ‘¦_2+ğ‘¥_2 ğ‘¦_2âˆ’ğ‘¥_2 ğ‘¦_1}{ğ‘¥_1âˆ’ğ‘¥_2}âˆ’ğ‘˜(ğ‘¥_2âˆ’ğ‘¥_0)\\
&=\frac{(ğ‘¥_0âˆ’ğ‘¥_2 )(ğ‘¦_1âˆ’ğ‘¦_2 )}{ğ‘¥_1âˆ’ğ‘¥_2}âˆ’ğ‘˜(ğ‘¥_0âˆ’ğ‘¥_2 )\\
&â‰¥\frac{(ğ‘¥_0âˆ’ğ‘¥_2 )(ğ‘¦_1âˆ’ğ‘¦_2 )}{ğ‘¥_1âˆ’ğ‘¥_2}âˆ’\frac{(ğ‘¥_0âˆ’ğ‘¥_2 )(ğ‘¦_1âˆ’ğ‘¦_2 )}{ğ‘¥_1âˆ’ğ‘¥_2}\\
&=0
\end{align}
$$

- ç»¼ä¸Šæ‰€è¿°ï¼Œåœ¨$y_1-kx_1$å’Œ$y_2-kx_2$ä¸­ä¸€å®šå­˜åœ¨ä¸€ä¸ªæ•°å°äºæˆ–ç­‰äº$x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0$ï¼Œåˆå› ä¸º$y_0-kx_0>x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0$ï¼Œæ‰€ä»¥åœ¨$y_1-kx_1$å’Œ$y_2-kx_2$ä¸­ä¸€å®šå­˜åœ¨ä¸€ä¸ªæ•°å°äº$y_0-kx_0$ï¼ŒçŸ›ç›¾ã€‚
- ç»¼ä¸Šæ‰€è¿°ï¼Œæ­¤æˆªè·çš„æœ€å°å€¼ä¸€å®šå–åœ¨ä¸‹å‡¸åŒ…ä¸Šã€‚
- è¯æ¯•ã€‚

#### å›å½’æ­£é¢˜

ç°åœ¨æˆ‘ä»¬çŸ¥é“äº†æœ€ä¼˜å†³ç­–ç‚¹ä¸€å®šåœ¨ä¸‹å‡¸åŒ…ä¸Š

é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆæ‰¾æœ€ä¼˜å†³ç­–ç‚¹å‘¢ï¼Ÿ

é¦–å…ˆæˆ‘ä»¬æ˜“å¾—ä¸‹å‡¸åŒ…ä¸­æ‰€æœ‰çº¿çš„æ–œç‡ä¸€å®šæ˜¯**å•è°ƒé€’å¢**çš„

å¦‚æœå­˜åœ¨ä¸‰ä¸ªä¸‹å‡¸åŒ…ä¸­çš„ç‚¹$(x_1,y_1 )$ï¼Œ$(x_2,y_2 )$ï¼Œ$(x_3,y_3 )$ä½¿å¾—$x_1<x_2<x_3$ä¸”$\frac{y_2-y_1}{x_2-x_1}>\frac{y_3-y_2}{x_3-x_2}$ï¼Œåˆ™$y_2-\frac{y_3-y_1}{x_3-x_1} x_2-\frac{x_3 y_1-x_1 y_3}{x_3-x_1}=\frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1}$

åˆå› ä¸º$x_1<x_2<x_3$ï¼Œæ‰€ä»¥$x_2-x_1>0$ï¼Œ$x_3-x_2>0$ï¼Œ$x_3-x_1>0$

æ•…$(y_2-y_1 )(x_3-x_2 )>(y_3-y_2 )(x_2-x_1 )$ï¼Œå³$x_2 y_1-x_3 y_1+x_3 y_2>x_1 y_2-x_1 y_3+x_2 y_3$

æ‰€ä»¥$\frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1}>0$ï¼Œæ•…$y_2>\frac{y_3-y_1}{x_3-x_1} x_2+\frac{x_3 y_1-x_1 y_3}{x_3-x_1}$ï¼Œæ‰€ä»¥$(x_2,y_2 )$ä¸€å®šä¸åœ¨ä¸‹å‡¸åŒ…å†…ã€‚

æ€è·¯å¾ˆæ¸…æ™°äº†å§ï¼Ÿ

### ç®€ç®€å•å•çš„ä»£ç 

```c++
#include<cstdio>
using namespace std;

const int N = 5e4 + 5;
int n, L, C, Qt[N], h = 1, t;
ll sum[N], f[N], Qx[N], Qy[N];

il ll sq(ll x) {return x * x;}
il double sl(ll x1, ll y1, ll x2, ll y2) {return (double) (y1 - y2) / (x1 - x2);}

int main() {
	scanf("%d%d%d", &n, &L, &C);
	sum[1] = C; f[1] = sq(C - L);
	Qt[++t] = 0; Qx[t] = L + 1; Qy[t] = sq(Qx[t]);
	Qt[++t] = 1; Qx[t] = L + 2 + C; Qy[t] = f[1] + sq(Qx[t]);
	for(int i = 2; i <= n; ++i) {
		scanf("%d", &C);
		sum[i] = sum[i - 1] + C;
		double slope = (i + sum[i]) << 1;
		while(h < t && sl(Qx[h], Qy[h], Qx[h + 1], Qy[h + 1]) < slope) ++h;
		f[i] = f[Qt[h]] + sq(i - Qt[h] - 1 + sum[i] - sum[Qt[h]] - L);
		ll X = i + sum[i] + L + 1, Y = f[i] + sq(X);
		while(h < t && sl(Qx[t], Qy[t], Qx[t - 1], Qy[t - 1]) >= sl(Qx[t], Qy[t], X, Y)) --t;
		Qt[++t] = i; Qx[t] = X, Qy[t] = Y;
	}
	printf("%lld\n", f[n]);
	return 0;
}
```

## é—®é¢˜æ¥äº†

è‹¥$C_k$å¯ä»¥å°äº 0 å‘¢ï¼Ÿåˆè¯¥æ€ä¹ˆåšï¼Ÿ

è¿™ä¸ªæˆ‘ä»¬ä¸€çœ¼å°±èƒ½çœ‹ç©¿è¿™ç©æ„**ä¸æ»¡è¶³å•è°ƒæ€§**ã€‚

å‡å¦‚è¯´è€ƒè¯•çš„æ—¶å€™ä½ ä¸ä¼šè¯æ–œç‡çš„ç‚¹æˆ–è€…å†³ç­–æœ‰/æ²¡æœ‰å•è°ƒæ€§æ€ä¹ˆåŠï¼Ÿ

æœ‰ä¸¤ç§æ–¹æ³•ã€‚ç¬¬ä¸€ç§æ˜¯æ‰“è¡¨ï¼Œå¤šæ‰“å‡ ç»„ã€‚

ç¬¬äºŒç§æ˜¯ä¸ç®¡ä¸‰ä¸ƒäºŒåä¸€ç›´æ¥ä¸Šä¸æ»¡è¶³å•è°ƒæ€§æ—¶çš„åšæ³•ã€‚åæ­£æ»¡è¶³å•è°ƒæ€§çš„æ—¶å€™ä¸æ»¡è¶³å•è°ƒæ€§æ—¶çš„åšæ³•ä¹Ÿèƒ½ç”¨ã€‚

ä¸æ»¡è¶³å•è°ƒæ€§çš„åšæ³•ï¼š

### åˆ†æ²»

æˆ‘ä»¬ç”¨$dc(l, r)$è¡¨ç¤ºè®¡ç®—$[l, r]$ä¸­çš„$dp_i$ã€‚

å¯¹äºå·¦åŠè¾¹ï¼Œæˆ‘ä»¬å…ˆç”¨$dc(l, mid)$ç®—å‡º$[l, mid]$ä¸­çš„$dp_i$ã€‚ç„¶åæˆ‘ä»¬å°±çŸ¥é“äº†æ‰€æœ‰çš„å†³ç­–ç‚¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥å»ºå‡¸åŒ…ã€‚ç„¶åæˆ‘ä»¬ç”¨è¿™ä¸ªå‡¸åŒ…å»æ›´æ–°$[mid, r]$ä¸­çš„$dp_i$ã€‚è¿™æ—¶çš„å‡¸åŒ…æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æŠŠ$[mid, r]$çš„æŸ¥è¯¢æ–œç‡æ’åºï¼Œç„¶åç”¨å•è°ƒé˜Ÿåˆ—ç»´æŠ¤ã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥åœ¨å‡¸åŒ…ä¸ŠäºŒåˆ†ã€‚

å¯¹äº$[mid, r]$ä¸­çš„æ¯ä¸ª$dp_i$ï¼Œå¦‚æœå®ƒçš„æœ€ä¼˜å†³ç­–ç‚¹åœ¨$[1, mid]$ï¼Œåˆ™ä¸Šä¸€æ­¥å·²ç»æ›´æ–°å®Œï¼Œå¦‚æœå®ƒçš„æœ€ä¼˜å†³ç­–ç‚¹ä¸åœ¨$[l, mid]$æˆ‘ä»¬ä¹Ÿä¸éœ€è¦$[l, mid]$çš„å‡¸åŒ…ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥æŠŠå·¦è¾¹çš„å‡¸åŒ…æŠ›æ‰ï¼Œç”¨$dc(mid + 1, r)$è®¡ç®—ä¹‹åçš„$dp_i$ã€‚

$T(n)=2T(\frac{n}{2})+O(n\log n))=O(n\log^2n)$

#### ä»£ç 

```c++
#include <vector>
#include <stdio.h>
#include <string.h>
#include <algorithm>

int n, h[100005], w[100005], pre[100005];
long long dp[100005], sum[100005];

struct Point {
	long long x, y;
	int id;
	Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) {}
	double operator/ (const Point &p) const { return (double) (y - p.y) / (x - p.x); }
};

long long min(long long a, long long b) { return a < b ? a : b; }

void cdq(int l, int r) {
	while (l != r) {
		std::vector<Point> Q, temp;
		int mid = (l + r) >> 1;
		cdq(l, mid);
		for (int i = l; i <= mid; ++i)
			temp.push_back(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));
		std::sort(temp.begin(), temp.end(), [] (const Point &p1, const Point &p2) {
			return p1.x == p2.x ? p1.y < p2.y : p1.x < p2.x;
		});
		Q.push_back(temp[0]); int _size = 0;
		for (int i = 1; i < (int) temp.size(); ++i) {
			if (Q[_size].x == temp[i].x) continue;
			while (_size && Q[_size] / Q[_size - 1] > Q[_size] / temp[i]) Q.pop_back(), --_size;
			Q.push_back(temp[i]); ++_size;
		}
		for (int i = r; i > mid; --i) {
			int l = 1, r = Q.size() - 1, sl = h[i] << 1;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (Q[mid] / Q[mid - 1] > sl) r = mid - 1;
				else l = mid + 1;
			}
			int k = Q[r].id;
			dp[i] = min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]);
		}
		l = mid + 1;
	}
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", h + i);
	for (int i = 1; i <= n; ++i) scanf("%d", w + i), sum[i] = sum[i - 1] + w[i];
	memset(dp, 0x3f, sizeof dp); dp[1] = 0;
	cdq(1, n); printf("%lld\n", dp[n]);
	return 0;
}
```

### å¹³è¡¡æ ‘

æ€è·¯å¾ˆç®€æ´ï¼Œä¸€è¯´å°±æ‡‚ï¼Œä¸€å†™å°±åºŸ

#### ä»£ç 

```c++
#include <stdio.h>
#include <string.h>

inline unsigned rand() {
	static unsigned seed = 19260817;
	return (seed = seed * 1279u + 10001279u) ^= (seed >> 7);
}

struct Point {
	long long x, y;
	int id;
	Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) {}
	Point() {}
	double operator/ (const Point &p) const { return (double) (y - p.y) / (x - p.x); }
};

struct Treap {
	struct node {
		int ls, rs, size;
		Point p;
		double lp, rp;
		unsigned key;
	} tr[100005];
	int cnt, root;
	inline int new_node(const Point &p) {
		tr[++cnt].p = p;
		tr[cnt].key = rand();
		tr[cnt].size = 1;
		return cnt;
	}
	inline void push_up(int k) { if (k) tr[k].size = tr[tr[k].ls].size + tr[tr[k].rs].size + 1; }
	void rotate_left(int &k) {
		int old_k = k;
		k = tr[k].rs;
		tr[old_k].rs = tr[k].ls;
		tr[k].ls = old_k;
		push_up(old_k);
		push_up(k);
	}
	void rotate_right(int &k) {
		int old_k = k;
		k = tr[k].ls;
		tr[old_k].ls = tr[k].rs;
		tr[k].rs = old_k;
		push_up(old_k);
		push_up(k);
	}
	int insert(int &k, const Point &v) {
		int tmp;
		if (!k) { return k = new_node(v); }
		if (v.x < tr[k].p.x) {
			if (tmp = insert(tr[k].ls, v)) {
				if (tr[k].key > tr[tr[k].ls].key) rotate_right(k);
				push_up(k);
				return tmp;
			} else return 0;
		} else if (v.x > tr[k].p.x) {
			if (tmp = insert(tr[k].rs, v)) {
				if (tr[k].key > tr[tr[k].rs].key) rotate_left(k);
				push_up(k);
				return tmp;
			} else return 0;
		} else {
			if (tr[k].p.y < v.y) return 0;
			tr[k].p.y = v.y; tr[k].p.id = v.id; return k;
		}
	}
	void remove(int &k, long long x) {
		if (!k) return;
		if (tr[k].p.x == x) {
			if (tr[k].ls && tr[k].rs) {
				if (tr[tr[k].ls].key < tr[tr[k].rs].key) rotate_right(k), remove(tr[k].rs, x);
				else rotate_left(k), remove(tr[k].ls, x);
			} else k = tr[k].ls | tr[k].rs;
		} else if (x < tr[k].p.x) remove(tr[k].ls, x);
		else remove(tr[k].rs, x);
		push_up(k);
	}
	int rank(long long x) {
		int rnk = 0, k = root;
		while (k) {
			if (x <= tr[k].p.x) k = tr[k].ls;
			else rnk += tr[tr[k].ls].size + 1, k = tr[k].rs;
		}
		return rnk + 1;
	}
	int value(int x) {
		if (x > tr[root].size || x <= 0) return -1;
		int k = root;
		while (k) {
			if (x <= tr[tr[k].ls].size) k = tr[k].ls;
			else if (x == tr[tr[k].ls].size + 1) return k;
			else x -= tr[tr[k].ls].size + 1, k = tr[k].rs;
		}
		return -1;
	}
	int prev(long long v) { return value(rank(v) - 1); }
	int next(long long v) { return value(rank(v + 1)); }
	void insert_hull(const Point &point) {
		int k = insert(root, point);
		if (!k) return;
		int k1 = prev(point.x);
		if (k1 != -1) {
			while (tr[k1].lp > point / tr[k1].p) remove(root, tr[k1].p.x), k1 = prev(tr[k1].p.x);
			tr[k].lp = tr[k1].rp = point / tr[k1].p;
		} else tr[k].lp = -1e30;
		int k2 = next(point.x);
		if (k2 != -1) {
			while (point / tr[k2].p > tr[k2].rp)
				remove(root, tr[k2].p.x), k2 = next(tr[k2].p.x);
			tr[k].rp = tr[k2].lp = tr[k2].p / point;
		} else tr[k].rp = 1e30;
		if (tr[k].lp > tr[k].rp) {
			remove(root, tr[k].p.x);
			tr[k1].rp = tr[k2].lp = tr[k1].p / tr[k2].p;
		}
	}
	int query_hull(long long slope) {
		int k = root;
		while (k) {
			if (tr[k].lp <= slope && slope <= tr[k].rp) return tr[k].p.id;
			else if (slope < tr[k].lp) k = tr[k].ls;
			else k = tr[k].rs;
		}
		return -1;
	}
} treap;

int n, w[100005], h[100005];
long long sum[100005], dp[100005];

long long min(long long a, long long b) { return a < b ? a : b; }

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", h + i);
	for (int i = 1; i <= n; ++i) scanf("%d", w + i), sum[i] = sum[i - 1] + w[i];
	memset(dp, 0x3f, sizeof dp); dp[1] = 0;
	treap.new_node(Point(h[1], (long long) h[1] * h[1] - w[1], 1));
	treap.root = 1; treap.tr[1].lp = -1e30; treap.tr[1].rp = 1e30;
	for (int i = 2; i <= n; ++i) {
		int j = treap.query_hull(h[i] << 1);
		dp[i] = min(dp[i], dp[j] + (long long) (h[i] - h[j]) * (h[i] - h[j]) + sum[i - 1] - sum[j]);
		treap.insert_hull(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));
	}
	printf("%lld", dp[n]);
	return 0;
}
```

### äºŒè¿›åˆ¶åˆ†ç»„

æˆ‘ä»¬å°†æ‰€æœ‰çš„ç‚¹åˆ†æˆè‹¥å¹²ç»„ï¼Œç¬¬$i$ç»„å¤§å°ä¸º$2^i$ï¼Œæ˜¾ç„¶ç»„æ•°ä¸è¶…è¿‡$O(\log n)$ã€‚æˆ‘ä»¬ç»´æŠ¤æ¯ç»„çš„å‡¸åŒ…ã€‚

æ’å…¥ä¸€ä¸ªç‚¹æ—¶ï¼Œè‹¥æ²¡æœ‰ç¬¬ 0 ç»„ï¼Œåˆ™å°†å®ƒä½œä¸ºç¬¬ 0 ç»„ï¼Œå¦åˆ™å°†å®ƒå’Œç¬¬ 0 ç»„åˆå¹¶ã€‚è¿™æ ·æˆ‘ä»¬å¾—åˆ°äº†ç¬¬ 1 ç»„ã€‚æ¥ä¸‹æ¥å¦‚æœæœ‰ç¬¬ 1 ç»„ï¼Œåˆ™å†å°†å®ƒä¸ç¬¬ 1 ç»„åˆå¹¶å¾—åˆ°ç¬¬ 2 ç»„â€¦â€¦ç±»ä¼¼äºŒè¿›åˆ¶+1 çš„è¿‡ç¨‹ã€‚

æŸ¥è¯¢åœ¨æ¯ä¸€ç»„åˆ†åˆ«äºŒåˆ†ï¼Œå–æœ€å¤§å³å¯ã€‚

å…³äºæ—¶é—´å¤æ‚åº¦ï¼š

æ˜¾ç„¶æ¯ä¸ªç‚¹æœ€å¤šè¢«åˆå¹¶$O(\log n)$æ¬¡ã€‚æˆ‘ä»¬åˆå¹¶ä¸¤ä¸ªåŒ…å«$O(n)$ä¸ªèŠ‚ç‚¹çš„å‡¸åŒ…çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$çš„ï¼Œæ•…å‡æ‘Šåˆ°æ¯ä¸ªç‚¹ä¸Šåˆå¹¶çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(1)$ï¼Œåˆå› ä¸ºå…±æœ‰$O(n)$ä¸ªç‚¹ï¼Œæ‰€ä»¥æ€»æ—¶é—´å¤æ‚åº¦$O(n\log n)$ã€‚

#### ä»£ç 

```c++
#include <string.h>
#include <stdio.h>
#include <vector>

int n, h[100005], w[100005];
long long dp[100005], sum[100005];

struct Point {
	long long x, y;
	int id;
	Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) {}
	double operator/ (const Point &p) const { return (double) (y - p.y) / (x - p.x); }
};

struct ConvexHull {
	std::vector<Point> p;
	void merge(ConvexHull &h) {
		std::vector<Point> possible_conv;
		int i = 0, j = 0;
		while (i < (int) p.size() && j < (int) h.p.size())
			if (p[i].x == h.p[j].x) {
				if (p[i].y < h.p[j].y) possible_conv.push_back(p[i]);
				else possible_conv.push_back(h.p[j]);
				++i; ++j;
			} else if (p[i].x < h.p[j].x) possible_conv.push_back(p[i]), ++i;
			else possible_conv.push_back(h.p[j]), ++j;
		while (i < (int) p.size()) possible_conv.push_back(p[i]), ++i;
		while (j < (int) h.p.size()) possible_conv.push_back(h.p[j]), ++j;
		p.clear(); p.push_back(possible_conv[0]);
		int _size = 0;
		for (int i = 1; i < (int) possible_conv.size(); ++i) {
			while (_size && p[_size] / p[_size - 1] > p[_size] / possible_conv[i]) p.pop_back(), --_size;
			p.push_back(possible_conv[i]); ++_size;
		}
		h.p.clear();
	}
	int query(long long k) {
		int l = 1, r = p.size() - 1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (p[mid] / p[mid - 1] > k) r = mid - 1;
			else l = mid + 1;
		}
		return p[r].id;
	}
	ConvexHull() {}
	ConvexHull(const Point &P) { p.push_back(P); }
} conv[17];

long long min(long long a, long long b) { return a < b ? a : b; }

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", h + i);
	for (int i = 1; i <= n; ++i) scanf("%d", w + i), sum[i] = sum[i - 1] + w[i];
	memset(dp, 0x3f, sizeof dp); dp[1] = 0;
	conv[0] = ConvexHull(Point(h[1], (long long) h[1] * h[1] - w[1], 1));
	for (int i = 2; i <= n; ++i) {
		for (int j = 0; j < 17; ++j) {
			if (conv[j].p.empty()) continue;
			int k = conv[j].query(h[i] << 1);
			dp[i] = min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]);
		}
		ConvexHull cv(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));
		for (int j = 0; j < 17; ++j) {
			if (conv[j].p.empty()) {
				conv[j].p = cv.p;
				break;
			}
			cv.merge(conv[j]);
		}
	}
	printf("%lld", dp[n]);
	return 0;
}
```

## æ€»ç»“

åœ¨$dp$çš„æœ€å°/æœ€å¤§åŒ–é—®é¢˜ä¸­ï¼Œå°†è½¬ç§»æ–¹ç¨‹åˆ†æˆå››éƒ¨åˆ†ï¼šä¸€éƒ¨åˆ†ä¸$i, j$éƒ½æ— å…³ï¼Œä¸€éƒ¨åˆ†åªä¸$j$æœ‰å…³ï¼Œä¸€éƒ¨åˆ†åªä¸$i$æœ‰å…³ï¼Œè¿˜æœ‰ä¸€éƒ¨åˆ†å’Œ$i, j$éƒ½æœ‰å…³ã€‚å¦‚æœå®ƒèƒ½å†™æˆ $y=kx+b$ çš„å½¢å¼ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå‡¸åŒ…ï¼Œæ¥è¿›è¡ŒçŠ¶æ€çš„è½¬ç§»ã€‚

## ç»ƒä¹ 

> æ­¤å¤„æ”¾å‡ºä½ è°·çš„é“¾æ¥

- [P4655 / loj 2483 Building Bridges](https://www.luogu.com.cn/problem/P4655)
- [P5017 / loj 3007 [NOIP2018 æ™®åŠç»„] æ‘†æ¸¡è½¦](https://www.luogu.com.cn/problem/P5017)
- [P4027 / loj 2353 [NOI2007] è´§å¸å…‘æ¢](https://www.luogu.com.cn/problem/P4027)
- [P3571 [POI2014] SUP-Supercomputer](https://www.luogu.com.cn/problem/P3571)
- [CF311B Cats Transport](https://www.luogu.com.cn/problem/CF311B)
